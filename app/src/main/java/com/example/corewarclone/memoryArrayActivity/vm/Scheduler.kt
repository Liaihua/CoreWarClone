package com.example.corewarclone.memoryArrayActivity.vm

import java.util.*

// TODO Догадайся

const val CYCLES_UNTIL_TIE = 100000
const val MAX_TASKS = 64

var Warriors = arrayOf<Warrior>()

class Warrior {
    var id: Int = 0
    var name: String = ""
    var taskQueue: ArrayDeque<Task> = ArrayDeque()

}

class Task {
    var id: Int = 0
    var instructionPointer: Int = -1
}

// Кажется, у меня появилась одна маленькая идея, как можно реализовать запуск и шаг на конкретную инструкцию.
// В чем она заключается: у нас есть глобальная переменная (нда, гениально), которую мы постоянно
// проверяем в цикле перед тем, как выполнить инструкцию. Когда мы нажимаем на кнопку "Шаг", переменная
// устанавливается в значение false, тем самым прерывая выполнение. В блоке else может быть код, который
// сохраняет контекст MemoryArray перед остановкой. Затем каждый раз, когда мы вызываем метод, привязанный
// к кнопке "Шаг", мы извлекаем контекст, выполняем 1 инструкцию и сохраняем контекст. Когда мы нажимаем на кнопку
// "Запуск" снова, мы устанавливаем глобальную переменную в значение true, извлекаем контекст, и продолжаем
// выполнять код

// Такое своеобразное подобие корутин.

class Scheduler {
    fun schedule() {}
}